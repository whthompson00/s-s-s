Our CS50 project incorporates many of the skills learned throughout the class as well as a few learned on our own.  In order to create a GLICKO rating system, we first needed to create SQL databases with all the relevant team information and game information.  Unfortunately, no free API existed to obtain this information, so we had to scrape the data off the ESPN webpage.  We used beautiful soup to generate a list of all the D1 men’s college basketball teams.  After that, we had to scrape in all the results from all the games already played in the 2018 season.  Fortunately, ESPN stores all the results from the games played on the same day in the same URL with the only the date changing for each day.  So to scrape all the data, we need a list of all the dates in the 2018-19 season.  To do this, we imported the datetime class to generate a list of dates going from the first day of the season to the last day of the season.  Iterating through this list of dates, we scraped the ESPN page of daily results and put the teams playing the games as well as the scores into a separate SQL database called records.  We did the scraping in two functions, loadTeams and loadGames, and called them each once in the main function.  Of course, new results will come in after we loaded the initial set of games.  So again using datetime as well as importing schedule, we automated the code to refresh for new scores daily.
After we created the SQL databases with all the teams and all the records, we then had to update the ratings and RDs, a statistic which captures the reliability of a ranking, of the teams based on their results.  Using Mark Glickman’s model, we created a new python page, called GLICKO.py, to handle all the calculations related to the updated rankings.  We then created a new function, updateRatings to handle this updating the results.  Specifically, updateRatings looks through the whole SQL records database and looks for games in which inserted = 0, which lets the computer know the ratings have not been updated for that result yet.  After some error handling in case an opponent was d3 etc., the function then calls functions in GLICKO to find the new ratings and RDs for both teams after the game.  Finally, the function updates the ratings and RDs in the teams SQL database and updates inserted to 1 in the records database to indicate that the game has been accounted for in the ratings.
Last, we had to turn the SQL databases into web results.  First, we needed to display new rankings based off the GLICKO ratings.  To do so, we had to call the teams SQL database and sort all the teams based on their ratings.  We utilized a recursively structured merge sort function to optimize the time of the sorting.  Then, in the rankings.html page, we used jinja to iterate through the sorted list of college basketball teams, displaying their rank with the help of the loop.index function in jinja as well as their GLICKO rating in the table.  Finally, in the headtohead.html page, we created a form where users could input any two teams and see the win percentages of the teams.  We then included some live error handling with the help of JavaScript, as well as some error handling in python in case the user entered an abbreviation for a team, such as Uva instead of Virginia.  The python then makes calls to the GLICKO method for projecting win probabilities and returns those to the html to display.  Ultimately, we wanted to create a dynamically updating dropdown menu for the user to choose from using JavaScript with the help of Ajax (sort of like how David did in lecture 7), but we simply had a little too much difficulty with that.
